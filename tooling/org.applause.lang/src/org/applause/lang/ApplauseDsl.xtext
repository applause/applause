grammar org.applause.lang.ApplauseDsl with org.eclipse.xtext.common.Terminals

generate applauseDsl "http://www.applause.org/lang/ApplauseDsl"

Model:
	elements += NamedElement*
;

NamedElement:
	Type | Platform | DataSource
;

// -----------------------------------------
// Entities
// -----------------------------------------

Type:
	DataType | Entity
;

DataType:
	'datatype' name=ID	
;

Entity:
	(abstract ?= 'abstract')? 'entity' name=ID ('extends' superType=[Entity])? '{'
		attributes += Attribute*
	'}'
;

Attribute:
	type=[Type]	(many?='[]')? name=ID
;

// -----------------------------------------
// Platform-specific mappings
// -----------------------------------------

Platform:
	'platform' name=ID '{'
		mappings += PlatformMapping*
	'}'
;

PlatformMapping:
	TypeMapping // | NamespaceMapping
;

TypeMapping:
	'typemapping' type=[DataType] '->' simpleName=ID
;

// -----------------------------------------
// Data Source
// -----------------------------------------

DataSource:
	'datasource' name=ID '{'
		'baseUrl' ':' baseUrl=STRING // TODO: change STRING to a real URL value type
		'resource' ':' resourceType=[Entity]
		methods += DataSourceAccessMethod*
	'}'
;

// TODO: As we can have multiple datasource for each entity, we should either:
// (a) make sure only one datasource cen be defined per dentity
// (b) there always is just one data source access method with the same name for any given entity
// IMO, (a) seems to be easier  
DataSourceAccessMethod:
	name=ID '(' (declaredParameters += Parameter (',' declaredParameters += Parameter)* )? ')' (returnsMany?='[]')? restSpecification=RESTSpecification 
;

RESTSpecification:
	verb=RESTVerb 
	path=STRING // TODO: change STRING to a real URL value type 
	('{' body=DataSourceBodySpecification '}')?	
;

DataSourceBodySpecification:
	bodycontents=[Parameter]	
;

enum RESTVerb:
	GET | POST | PUT | DELETE
;

Parameter:
	type=[Type] name=ID	
;

